简单工厂模式：
    缺点：FruitFactory不符合【开放-封闭】原则，要不断的修改这个工厂类，工厂方法模式能解决这个问题
工厂方法模式：
    能解决简单工厂模式的缺点，通过工厂接口实现，不同的工厂都实现这个工厂接口(所以我理解好的代码是不断的增加类和接口，而不是修改原有的类)
抽象工厂模式:
    缺点：增加产品类要增加具体的工厂
单例模式：
    单例模式是一种对象创建型模式，使用单例模式，
    可以保证为一个类只生成唯一的实例对象。也就是说，
    在整个程序空间中，该类只存在一个实例对象。
        其实，GoF对单例模式的定义是：保证一个类、
    只有一个实例存在，同时提供能对该实例加以访
    问的全局访问方法。
    在应用系统开发中，我们常常有以下需求：
    - 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象
    - 在整个程序空间使用全局变量，共享资源
    - 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

    因为Singleton模式可以保证为一个类只生成唯一的实例
    对象，所以这些情况，Singleton模式就派上用场了。

    饿汉式 Person  多线程可以保证一个实例
    懒汉式 Person2 多线程不能保证一个实例
           Person3能保证一个实例(但是不好！！！
                  因为在方法上加上了synchronized,而我们只是想在第一次new对象的时候保证多线程只产生一个对象，以后肯定就是用new出来这个对象了，在方法上加同步有点太重量级了)
    双重检查 Person4

原型模式：
    概念：Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据
    特点：1. 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。
          2.目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。
          3.根据对象克隆深度层次的不同，有浅度克隆与深度克隆。
                    浅度克隆：如果对象中有引用类型比如一个对象或者List等，这种通过java的clone方法只会clone引用，不能和原对象完全独立，就是你可以clone出来对象，
                              但是clone出来的对象如果原对象中的引用类型发生了变化，则新clone出来对象中的引用类型也会发生变化
                              public class Person implements Cloneable{
                                private List<String> friends;//引用类型 clone后和原对象共用这个对象的堆内存,也就是你增加一个friend元素，clone的对象也增加元素
                                public Person clone() {
                                    return (Person)super.clone();//这种就是浅度克隆,也就是被clone对象和原对象没有完全剥离
                                }
                              }
                    深度克隆(引用类型自己手动赋值):
                            public Person clone() {
                                try {
                                    Person person  = (Person)super.clone();
                                    List<String> newfriends = new ArrayList<String>();
                                    for(String friend : this.getFriends()) {
                                        newfriends.add(friend);
                                    }
                                    person.setFriends(newfriends);
                                    return  person;
                                } catch (CloneNotSupportedException e) {
                                    e.printStackTrace();
                                    return null;
                                }
                            }
    应用场景：
          - 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
          - 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
          - 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节