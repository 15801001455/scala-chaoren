简单工厂模式：
    缺点：FruitFactory不符合【开放-封闭】原则，要不断的修改这个工厂类，工厂方法模式能解决这个问题
工厂方法模式：
    能解决简单工厂模式的缺点，通过工厂接口实现，不同的工厂都实现这个工厂接口(所以我理解好的代码是不断的增加类和接口，而不是修改原有的类)
抽象工厂模式:
    缺点：增加产品类要增加具体的工厂
单例模式：
    单例模式是一种对象创建型模式，使用单例模式，
    可以保证为一个类只生成唯一的实例对象。也就是说，
    在整个程序空间中，该类只存在一个实例对象。
        其实，GoF对单例模式的定义是：保证一个类、
    只有一个实例存在，同时提供能对该实例加以访
    问的全局访问方法。
    在应用系统开发中，我们常常有以下需求：
    - 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象
    - 在整个程序空间使用全局变量，共享资源
    - 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

    因为Singleton模式可以保证为一个类只生成唯一的实例
    对象，所以这些情况，Singleton模式就派上用场了。

    饿汉式 Person  多线程可以保证一个实例
    懒汉式 Person2 多线程不能保证一个实例
           Person3能保证一个实例(但是不好！！！
                  因为在方法上加上了synchronized,而我们只是想在第一次new对象的时候保证多线程只产生一个对象，以后肯定就是用new出来这个对象了，在方法上加同步有点太重量级了)
    双重检查 Person4

原型模式：
    概念：Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据
    特点：1. 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。
          2.目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。
          3.根据对象克隆深度层次的不同，有浅度克隆与深度克隆。
                    浅度克隆：如果对象中有引用类型比如一个对象或者List等，这种通过java的clone方法只会clone引用，不能和原对象完全独立，就是你可以clone出来对象，
                              但是clone出来的对象如果原对象中的引用类型发生了变化，则新clone出来对象中的引用类型也会发生变化
                              public class Person implements Cloneable{
                                private List<String> friends;//引用类型 clone后和原对象共用这个对象的堆内存,也就是你增加一个friend元素，clone的对象也增加元素
                                public Person clone() {
                                    return (Person)super.clone();//这种就是浅度克隆,也就是被clone对象和原对象没有完全剥离
                                }
                              }
                    深度克隆(引用类型自己手动赋值):
                            public Person clone() {
                                try {
                                    Person person  = (Person)super.clone();
                                    List<String> newfriends = new ArrayList<String>();
                                    for(String friend : this.getFriends()) {
                                        newfriends.add(friend);
                                    }
                                    person.setFriends(newfriends);
                                    return  person;
                                } catch (CloneNotSupportedException e) {
                                    e.printStackTrace();
                                    return null;
                                }
                            }
    应用场景：
          - 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
          - 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
          - 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节

建造者模式：
    主要是防止客户自己造房子，引入了工程队和指挥者(HouseDirector),指挥者没什么内容，就是拼装工程队的各个方法
        对象的创建：Builder模式是为对象的创建而设计的模式
        - 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象
        - 关注对象创建的各部分的创建过程：不同的工厂（这里指builder生成器）对产品属性有不同的创建方法

装饰模式(主要用于替换继承模式): 参考java FileReader等
     装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案
     我的理解：
        为什么会替换继承模式，因为继承我们要写接口，接口里定义很多方法，所有子类都要去实现，但是子类是有差异化的，有些父类的方法不是我想要的，
        装饰模式的思想就是子类定制化，接口父类只是提供最基本的需要所有子类实现的方法。
     抽象组件角色： 一个抽象接口，是被装饰类和装饰类的父接口。
     具体组件角色：为抽象组件的实现类。
     抽象装饰角色：包含一个组件的引用，并定义了与抽象组件一致的接口。
     具体装饰角色：为抽象装饰角色的实现类。负责具体的装饰。

策略模式：
    Strategy模式也叫策略模式是行为模式之一，
    它对一系列的算法加以封装，为所有算法定义一
    个抽象的算法接口，并通过继承该抽象算法接口
    对所有的算法加以封装和实现，具体的算法选择
    交由客户端决定（策略）。Strategy模式主要用
    来平滑地处理算法的切换
    策略模式的缺点有：
    1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。
    2. 策略模式造成很多的策略类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。

观察者模式：
    Person（被观察者,可以通知多个观察者）
    MyObserver(观察者)
    Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
    Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。
    Observer模式的典型应用
    - 侦听事件驱动程序设计中的外部事件
    - 侦听/监视某个对象的状态变化
    - 发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者