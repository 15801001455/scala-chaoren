简单工厂模式：
    缺点：FruitFactory不符合【开放-封闭】原则，要不断的修改这个工厂类，工厂方法模式能解决这个问题
工厂方法模式：
    能解决简单工厂模式的缺点，通过工厂接口实现，不同的工厂都实现这个工厂接口(所以我理解好的代码是不断的增加类和接口，而不是修改原有的类)
抽象工厂模式:
    缺点：增加产品类要增加具体的工厂
单例模式：
    单例模式是一种对象创建型模式，使用单例模式，
    可以保证为一个类只生成唯一的实例对象。也就是说，
    在整个程序空间中，该类只存在一个实例对象。
        其实，GoF对单例模式的定义是：保证一个类、
    只有一个实例存在，同时提供能对该实例加以访
    问的全局访问方法。
    在应用系统开发中，我们常常有以下需求：
    - 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象
    - 在整个程序空间使用全局变量，共享资源
    - 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

    因为Singleton模式可以保证为一个类只生成唯一的实例
    对象，所以这些情况，Singleton模式就派上用场了。

    饿汉式 Person  多线程可以保证一个实例
    懒汉式 Person2 多线程不能保证一个实例
           Person3能保证一个实例(但是不好！！！
                  因为在方法上加上了synchronized,而我们只是想在第一次new对象的时候保证多线程只产生一个对象，以后肯定就是用new出来这个对象了，在方法上加同步有点太重量级了)
    双重检查 Person4

原型模式：
    概念：Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据
    特点：1. 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。
          2.目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。
          3.根据对象克隆深度层次的不同，有浅度克隆与深度克隆。
                    浅度克隆：如果对象中有引用类型比如一个对象或者List等，这种通过java的clone方法只会clone引用，不能和原对象完全独立，就是你可以clone出来对象，
                              但是clone出来的对象如果原对象中的引用类型发生了变化，则新clone出来对象中的引用类型也会发生变化
                              public class Person implements Cloneable{
                                private List<String> friends;//引用类型 clone后和原对象共用这个对象的堆内存,也就是你增加一个friend元素，clone的对象也增加元素
                                public Person clone() {
                                    return (Person)super.clone();//这种就是浅度克隆,也就是被clone对象和原对象没有完全剥离
                                }
                              }
                    深度克隆(引用类型自己手动赋值):
                            public Person clone() {
                                try {
                                    Person person  = (Person)super.clone();
                                    List<String> newfriends = new ArrayList<String>();
                                    for(String friend : this.getFriends()) {
                                        newfriends.add(friend);
                                    }
                                    person.setFriends(newfriends);
                                    return  person;
                                } catch (CloneNotSupportedException e) {
                                    e.printStackTrace();
                                    return null;
                                }
                            }
    应用场景：
          - 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
          - 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
          - 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节

建造者模式：
    主要是防止客户自己造房子，引入了工程队和指挥者(HouseDirector),指挥者没什么内容，就是拼装工程队的各个方法
        对象的创建：Builder模式是为对象的创建而设计的模式
        - 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象
        - 关注对象创建的各部分的创建过程：不同的工厂（这里指builder生成器）对产品属性有不同的创建方法

装饰模式(主要用于替换继承模式): 参考java FileReader等
     装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案
     我的理解：
        为什么会替换继承模式，因为继承我们要写接口，接口里定义很多方法，所有子类都要去实现，但是子类是有差异化的，有些父类的方法不是我想要的，
        装饰模式的思想就是子类定制化，接口父类只是提供最基本的需要所有子类实现的方法。
     抽象组件角色： 一个抽象接口，是被装饰类和装饰类的父接口。
     具体组件角色：为抽象组件的实现类。
     抽象装饰角色：包含一个组件的引用，并定义了与抽象组件一致的接口。
     具体装饰角色：为抽象装饰角色的实现类。负责具体的装饰。

策略模式：
    Strategy模式也叫策略模式是行为模式之一，
    它对一系列的算法加以封装，为所有算法定义一
    个抽象的算法接口，并通过继承该抽象算法接口
    对所有的算法加以封装和实现，具体的算法选择
    交由客户端决定（策略）。Strategy模式主要用
    来平滑地处理算法的切换
    策略模式的缺点有：
    1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。
    2. 策略模式造成很多的策略类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。

观察者模式：
    Person（被观察者,可以通知多个观察者）
    MyObserver(观察者)
    Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
    Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。
    Observer模式的典型应用
    - 侦听事件驱动程序设计中的外部事件
    - 侦听/监视某个对象的状态变化
    - 发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者

享元模式:
    Flyweight模式也叫享元模式，是构造型模式之一，它通过与其他类似对象共享数据来减小内存占用
    抽象享元角色：
          所有具体享元类的父类，规定一些需要实现的公共接口。
    具体享元角色：
       抽象享元角色的具体实现类，并实现了抽象享元角色规定的方法。
    享元工厂角色：
          负责创建和管理享元角色。

代理模式：
    Proxy模式又叫做代理模式，是构造型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
    所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标
    类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。
    subject（抽象主题角色）：
           真实主题与代理主题的共同接口。
    RealSubject（真实主题角色）：
        定义了代理角色所代表的真实对象。 
    Proxy（代理主题角色）：    
           含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。
    动态代理：
        1. 代理类实现InvocationHandler接口
        2. 代理类实现InvocationHandler接口的invoke方法，返回代理对象
        3. Proxy.newProxyInstance();

外观模式：
    Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具
    有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。
    Facade    为调用方定义简单的调用接口。
    Clients   调用者。通过Facade接口调用提供某功能的内部类群。
    Packages   功能提供者。指提供功能的类群（模块或子系统）

组合模式：
    Composite模式也叫组合模式，是构造型的设计模式之一。通过递归手段来构造树形的对象结构，并可以通过一个对象来访问整个对象树
    Component （树形结构的节点抽象）
    - 为所有的对象定义统一的接口（公共属性，行为等的定义）
    - 提供管理子节点对象的接口方法
    - [可选]提供管理父节点对象的接口方法

    Leaf （树形结构的叶节点）
    Component的实现子类

    Composite（树形结构的枝节点）
    Component的实现子类


