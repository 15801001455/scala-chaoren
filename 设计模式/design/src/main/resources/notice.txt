简单工厂模式：
    缺点：FruitFactory不符合【开放-封闭】原则，要不断的修改这个工厂类，工厂方法模式能解决这个问题
工厂方法模式：
    能解决简单工厂模式的缺点，通过工厂接口实现，不同的工厂都实现这个工厂接口(所以我理解好的代码是不断的增加类和接口，而不是修改原有的类)
抽象工厂模式:
    缺点：增加产品类要增加具体的工厂
单例模式：
    单例模式是一种对象创建型模式，使用单例模式，
    可以保证为一个类只生成唯一的实例对象。也就是说，
    在整个程序空间中，该类只存在一个实例对象。
        其实，GoF对单例模式的定义是：保证一个类、
    只有一个实例存在，同时提供能对该实例加以访
    问的全局访问方法。
    在应用系统开发中，我们常常有以下需求：
    - 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象
    - 在整个程序空间使用全局变量，共享资源
    - 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

    因为Singleton模式可以保证为一个类只生成唯一的实例
    对象，所以这些情况，Singleton模式就派上用场了。

    饿汉式 Person  多线程可以保证一个实例
    懒汉式 Person2 多线程不能保证一个实例
           Person3能保证一个实例(但是不好！！！
                  因为在方法上加上了synchronized,而我们只是想在第一次new对象的时候保证多线程只产生一个对象，以后肯定就是用new出来这个对象了，在方法上加同步有点太重量级了)
    双重检查 Person4

原型模式：
    概念：Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据
    特点：1. 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。
          2.目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。
          3.根据对象克隆深度层次的不同，有浅度克隆与深度克隆。
                    浅度克隆：如果对象中有引用类型比如一个对象或者List等，这种通过java的clone方法只会clone引用，不能和原对象完全独立，就是你可以clone出来对象，
                              但是clone出来的对象如果原对象中的引用类型发生了变化，则新clone出来对象中的引用类型也会发生变化
                              public class Person implements Cloneable{
                                private List<String> friends;//引用类型 clone后和原对象共用这个对象的堆内存,也就是你增加一个friend元素，clone的对象也增加元素
                                public Person clone() {
                                    return (Person)super.clone();//这种就是浅度克隆,也就是被clone对象和原对象没有完全剥离
                                }
                              }
                    深度克隆(引用类型自己手动赋值):
                            public Person clone() {
                                try {
                                    Person person  = (Person)super.clone();
                                    List<String> newfriends = new ArrayList<String>();
                                    for(String friend : this.getFriends()) {
                                        newfriends.add(friend);
                                    }
                                    person.setFriends(newfriends);
                                    return  person;
                                } catch (CloneNotSupportedException e) {
                                    e.printStackTrace();
                                    return null;
                                }
                            }
    应用场景：
          - 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
          - 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
          - 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节

建造者模式：
    主要是防止客户自己造房子，引入了工程队和指挥者(HouseDirector),指挥者没什么内容，就是拼装工程队的各个方法
        对象的创建：Builder模式是为对象的创建而设计的模式
        - 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象
        - 关注对象创建的各部分的创建过程：不同的工厂（这里指builder生成器）对产品属性有不同的创建方法

装饰模式(主要用于替换继承模式): 参考java FileReader等
     装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案
     我的理解：
        为什么会替换继承模式，因为继承我们要写接口，接口里定义很多方法，所有子类都要去实现，但是子类是有差异化的，有些父类的方法不是我想要的，
        装饰模式的思想就是子类定制化，接口父类只是提供最基本的需要所有子类实现的方法。
     抽象组件角色： 一个抽象接口，是被装饰类和装饰类的父接口。
     具体组件角色：为抽象组件的实现类。
     抽象装饰角色：包含一个组件的引用，并定义了与抽象组件一致的接口。
     具体装饰角色：为抽象装饰角色的实现类。负责具体的装饰。

策略模式：
    Strategy模式也叫策略模式是行为模式之一，
    它对一系列的算法加以封装，为所有算法定义一
    个抽象的算法接口，并通过继承该抽象算法接口
    对所有的算法加以封装和实现，具体的算法选择
    交由客户端决定（策略）。Strategy模式主要用
    来平滑地处理算法的切换
    策略模式的缺点有：
    1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。
    2. 策略模式造成很多的策略类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。

观察者模式：
    Person（被观察者,可以通知多个观察者）
    MyObserver(观察者)
    Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
    Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。
    Observer模式的典型应用
    - 侦听事件驱动程序设计中的外部事件
    - 侦听/监视某个对象的状态变化
    - 发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者

享元模式:
    Flyweight模式也叫享元模式，是构造型模式之一，它通过与其他类似对象共享数据来减小内存占用
    抽象享元角色：
          所有具体享元类的父类，规定一些需要实现的公共接口。
    具体享元角色：
       抽象享元角色的具体实现类，并实现了抽象享元角色规定的方法。
    享元工厂角色：
          负责创建和管理享元角色。

代理模式：
    Proxy模式又叫做代理模式，是构造型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
    所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标
    类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。
    subject（抽象主题角色）：
           真实主题与代理主题的共同接口。
    RealSubject（真实主题角色）：
        定义了代理角色所代表的真实对象。 
    Proxy（代理主题角色）：    
           含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。
    动态代理：
        1. 代理类实现InvocationHandler接口
        2. 代理类实现InvocationHandler接口的invoke方法，返回代理对象
        3. Proxy.newProxyInstance();

外观模式：
    Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具
    有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。
    Facade    为调用方定义简单的调用接口。
    Clients   调用者。通过Facade接口调用提供某功能的内部类群。
    Packages   功能提供者。指提供功能的类群（模块或子系统）
########################################################################
组合模式：
    Composite模式也叫组合模式，是构造型的设计模式之一。通过递归手段来构造树形的对象结构，并可以通过一个对象来访问整个对象树
    Component （树形结构的节点抽象）
    - 为所有的对象定义统一的接口（公共属性，行为等的定义）
    - 提供管理子节点对象的接口方法
    - [可选]提供管理父节点对象的接口方法

    Leaf （树形结构的叶节点）
    Component的实现子类

    Composite（树形结构的枝节点）
    Component的实现子类
########################################################################
桥接模式:
    Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。
    它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。
    Client
        Bridge模式的使用者
    Abstraction
        抽象类接口（接口或抽象类）
        维护对行为实现（Implementor）的引用
    Refined Abstraction
        Abstraction子类
    Implementor
        行为实现类接口 (Abstraction接口定义了基于Implementor接口的更高层次的操作)
    ConcreteImplementor
        Implementor子类
########################################################################
适配器模式：
    Adapter模式也叫适配器模式，是构造型模式之一，通过Adapter模式可以改变已有类（或外部类）的接口形式。
    在大规模的系统开发过程中，我们常常碰到诸如以下这些情况：
    我们需要实现某些功能，这些功能已有还不太成熟的一个或多个外部组件，如果我们自己重新开发这些功能会花费大量时间；所以很
    多情况下会选择先暂时使用外部组件，以后再考虑随时替换。但这样一来，会带来一个问题，随着对外部组件库的替换，可能需要对
    引用该外部组件的源代码进行大面积的修改，因此也极可能引入新的问题等等。如何最大限度的降低修改面呢？
    Adapter模式就是针对这种类似需求而提出来的。
    Adapter模式通过定义一个新的接口（对要实现的功能加以抽象），和一个实现该接口的Adapter（适配器）类来透明地调用外部组件。
    这样替换外部组件时，最多只要修改几个Adapter类就可以了，其他源代码都不会受到影响。
########################################################################
解释器模式：
    Interpreter模式也叫解释器模式，是行为模式之一，它是一种特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。
    简单地说，Interpreter模式是一种简单的语法解释器构架
    当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 
    该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。
    它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 
    效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。
    例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。
    Context    解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。
    AbstractExpression    解释器抽象类。
    ConcreteExpression    解释器具体实现类。
########################################################################
中介者模式:我的理解是防止类之间的互相调用，而是通过中介者统一管理，这个每个关联类就都要持有中介者的引用就可以了
    Mediator模式也叫中介者模式，是由GoF提出的23种
    软件设计模式的一种。Mediator模式是行为模式之一，
    在Mediator模式中，类之间的交互行为被统一放在
    Mediator的对象中，对象通过Mediator对象同其他对象
    交互，Mediator对象起着控制器的作用。
    mediator  中介者类的抽象父类。
    concreteMediator  具体的中介者类。
    colleague 关联类的抽象父类。
    concreteColleague  具体的关联类
    优点：
    1，将系统按功能分割成更小的对象，符合类的最小设计原则
    2，对关联对象的集中控制
    3，减小类的耦合程度，明确类之间的相互关系：当类之间的关系过于复杂时，其中任何一个类的修改都会影响到其他类，不符合类的设计的开闭原则 ，而Mediator模式将原来相互依存的多对多的类之间的关系简化为Mediator控制类与其他关联类的一对多的关系，当其中一个类修改时，可以对其他关联类不产生影响（即使有修改，也集中在Mediator控制类）。
    4，有利于提高类的重用性
########################################################################
职责链模式：
     Chain of Responsibility（CoR）模式也叫职
    责链模式或者职责连锁模式，是行为模式之一，
    该模式构造一系列分别担当不同的职责的类的对
    象来共同完成一个任务，这些类的对象之间像链
    条一样紧密相连，所以被称作职责链模式
    例1：比如客户Client要完成一个任务，这个任务包括a,b,c,d四个部分。首先客户Client把任务交给A，A完成a部分之后，把任务交给B，B完成b部分，...，直到D完成d部分。
    例2：比如政府部分的某项工作，县政府先完成自己能处理的部分，不能处理的部分交给省政府，省政府再完成自己职责范围内的部分，不能处理的部分交给中央政府，中央政府最后完成该项工作。
    例3：软件窗口的消息传播。
    例4：SERVLET容器的过滤器（Filter）框架实现。
    要实现Chain of Responsibility模式，需要满足该模式
    的基本条件：
    1，对象链的组织。需要将某任务的所有职责执行对象以链的形式加以组织。
    2，消息或请求的传递。将消息或请求沿着对象链传递，以让处于对象链中的对象得到处理机会。
    3，处于对象链中的对象的职责分配。不同的对象完成不同的职责。
    4，任务的完成。处于对象链的末尾的对象结束任务并停止消息或请求的继续传递。
    Handler
        处理类的抽象父类。
    concreteHandler
        具体的处理类。
    优点：
        1。责任的分担。每个类只需要处理自己该处理的工作（不该处理的传递给下一个对象完成），明确各类的责任范围，符合类的最小封装原则。
        2。可以根据需要自由组合工作流程。如工作流程发生变化，可以通过重新分配对象链便可适应新的工作流程。
        3。类与类之间可以以松耦合的形式加以组织。
    缺点：
        因为处理时以链的形式在对象间传递消息，根据实现方式不同，有可能会影响处理的速度。
########################################################################
迭代模式：（参考Iterator实现,了解即可 看代码就行）
     Iterator模式也叫迭代模式，是行为模式之
    一，它把对容器中包含的内部对象的访问委让给
    外部类，使用Iterator（遍历）按顺序进行遍历
    访问的设计模式。
    在应用Iterator模式之前，首先应该明白Iterator
    模式用来解决什么问题。或者说，如果不使用
    Iterator模式，会存在什么问题。
    1.由容器自己实现顺序遍历。直接在容器类里直接添加顺序遍历方法
    2.让调用者自己实现遍历。直接暴露数据细节给外部
    以上方法1与方法2都可以实现对遍历，这样有问题呢？
    1，容器类承担了太多功能：一方面需要提供添加删除等本身应有的功能；一方面还需要提供遍历访问功能。
    2，往往容器在实现遍历的过程中，需要保存遍历状态，当跟元素的添加删除等功能夹杂在一起，很容易引起混乱和程序运行错误等
    Iterator模式就是为了有效地处理按顺序进行遍历访问的一种设计模式，简单地说，Iterator模式提供一种有效的方法，可以屏蔽聚集对象集合的容器类的实现细节，
    而能对容器内包含的对象元素按顺序进行有效的遍历访问。
    所以，Iterator模式的应用场景可以归纳为满足以下几个
    条件：- 访问容器中包含的内部对象- 按顺序访问
    Iterator（迭代器接口）：
    该接口必须定义实现迭代功能的最小定义方法集
    比如提供hasNext()和next()方法。
    ConcreteIterator（迭代器实现类）：
    迭代器接口Iterator的实现类。可以根据具体情况加以实现。
    Aggregate（容器接口）：
    定义基本功能以及提供类似Iterator iterator()的方法。
    concreteAggregate（容器实现类）：
    容器接口的实现类。必须实现Iterator iterator()方法。
    优点：
    1，实现功能分离，简化容器接口。让容器只实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则。
    2，隐藏容器的实现细节。
    3，为容器或其子容器提供了一个统一接口，一方面方便调用；另一方面使得调用者不必关注迭代器的实现细节。
    4，可以为容器或其子容器实现不同的迭代方法或多个迭代方法。
########################################################################
模板方法模式：（MakeCar类中的make方法,我理解模板方法就是抽象父类中的一个具体实现代码） 细节不同，但是步骤相同
    Template Method模式也叫模板方法模式，是行为模式之一，它把具有特定步骤算法中的某些
    必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法的行为。
    Template Method模式一般应用在具有以下条件
    的应用中：
    - 具有统一的操作步骤或操作过程
    - 具有不同的操作细节
    - 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同
########################################################################
备忘录模式：
    Memento模式也叫备忘录模式，是行为模式之
    一，它的作用是保存对象的内部状态，并在需要
    的时候（undo/rollback）恢复对象以前的状态。
    如果一个对象需要保存状态并可通过undo或rollback等
    操作恢复到以前的状态时，可以使用Memento模式。1）一个类需要保存它的对象的状态（相当于Originator角色）2）设计一个类，该类只是用来保存上述对象的状态（相当于Memento角色）3）需要的时候，Caretaker角色要求Originator返回一个Memento并加以保存4）undo或rollback操作时，通过Caretaker保存的Memento恢复Originator对象的状态
    Originator（原生者）
        需要被保存状态以便恢复的那个对象。
    Memento（备忘录）
        该对象由Originator创建，主要用来保存Originator的内部状态。
    Caretaker（管理者）
        负责在适当的时间保存/恢复Originator对象的状态。

########################################################################
状态模式：
    State模式也叫状态模式，是行为设计模式的一种。State模式允许通过改变对象的内部状态而改变对象的行为，这个对象表现得就好像修改了它的类一样
    状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转译到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。
    Context：用户对象
    拥有一个State类型的成员，以标识对象的当前
    状态；
    State：接口或基类
    封装与Context的特定状态相关的行为；
    ConcreteState：接口实现类或子类
    实现了一个与Context某个状态相关的行为。
########################################################################
命令模式：
    Command模式也叫命令模式 ，是行为设计模
    式的一种。Command模式通过被称为
    Command的类封装了对目标对象的调用行为以
    及调用参数。
在面向对象的程序设计中，一个对象调用另一个对象，
一般情况下的调用过程是：创建目标对象实例；设置调
用参数；调用目标对象的方法。但在有些情况下有必要使用一个专门的类对这种调用
过程加以封装，我们把这种专门的类称作command类。- 整个调用过程比较繁杂，或者存在多处这种调用。
这时，使用Command类对该调用加以封装，便于功能的
再利用。- 调用前后需要对调用参数进行某些处理。- 调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等。

########################################################################
访问者模式：
     Visitor模式也叫访问者模式，是行为模式之一
    ，它分离对象的数据和行为，使用Visitor模式，
    可以不修改已有类的情况下，增加新的操作。
比如有一个公园，有一到多个不同的组成部分；该公
园存在多个访问者：清洁工A负责打扫公园的A部分，清
洁工B负责打扫公园的B部分，公园的管理者负责检点各
项事务是否完成，上级领导可以视察公园等等。也就是
说，对于同一个公园，不同的访问者有不同的行为操
作，而且访问者的种类也可能需要根据时间的推移而变
化（行为的扩展性）。根据软件设计的开闭原则（对修改关闭，对扩展开
放），我们怎么样实现这种需求呢？
1) 访问者角色（Visitor）：
     为该对象结构中具体元素角色声明一个访问操作接口。该操作接
口的名字和参数标识了发送访问请求给具体访问者的具体元素角色。
这样访问者就可以通过该元素角色的特定接口直接访问它。
2) 具体访问者角色（Concrete Visitor）：
     实现每个由访问者角色（Visitor）声明的操作。
3) 元素角色（Element）：
      定义一个Accept操作，它以一个访问者为参数。
4) 具体元素角色（Concrete Element）：
     实现由元素角色提供的Accept操作。
5) 对象结构角色（Object Structure）：
      这是使用访问者模式必备的角色。它要具备以下特征：能枚举
它的元素；可以提供一个高层的接口以允许该访问者访问它的元
素；可以是一个复合（组合模式）或是一个集合，如一个列表或一个无序
集合。
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
########################################################################
